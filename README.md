# **Pintos Project 1 — Threads (KAIST)**

**Pintos**는 교육용 운영체제 커널입니다. 실제 상용 OS의 방대한 복잡도 대신, **작지만 진짜로 동작하는 커널**을 통해 핵심 개념을 직접 구현·실험하게 합니다. Project 1은 **스레드, 동기화, 스케줄링**을 다루며, “동시에 돌아가는 코드가 자원을 어떻게 공유해야 안전한가?”라는 운영체제의 첫 질문에 답하게 해 줍니다.

## **프로젝트 1 한눈에 보기**

- **무엇을 만드나?**
    
    커널 수준 스레드의 **스케줄링과 동기화 원리**를 구현·강화합니다. 타이머 슬립, 우선순위 기반 스케줄링, **우선순위 역전 해결(우선순위 기부, Priority Donation)**, 그리고 **다단계 피드백 큐 스케줄러(MLFQS)** 를 구현합니다.
    
- **왜 배우나? (교육적 의도)**
    - **경쟁 상태와 교착 회피**: 락/세마포어/조건변수의 **정확한 사용 패턴**을 익힙니다.
    - **스케줄링 사고방식**: 우선순위, 대기, 기아 방지, **응답성**과 **공정성**의 균형을 고민합니다.
    - **시분할 시스템 감각**: 타이머 인터럽트와 **시간 공유** 메커니즘을 체득합니다.

## **구현 기능 요약 (설계 포인트)**

### **1) Alarm Clock (timer_sleep)**

- **하는 일**: 지정한 tick 동안 **바쁘게 기다리지 않고** 잠들었다가 깨어나기
- **설계 포인트**:
    - 슬립 대기 리스트를 **절전 구조**로 관리(최소 웨이크업 tick 기준 정렬)
    - 타이머 인터럽트에서 **깨울 스레드만 선택적으로** 깨우기 → 오버헤드 감소

### **2) 우선순위 스케줄링 (Priority Scheduling)**

- **하는 일**: **우선순위가 높은 스레드**가 먼저 실행되도록 준비 큐 관리
- **설계 포인트**:
    - 준비 큐(ready list)를 **우선순위 기준**으로 정렬
    - 새 스레드/우선순위 변경 시 **즉시 선점(preemption)** 고려

### **3) 우선순위 기부 (Priority Donation)**

- **하는 일**: 낮은 우선순위 스레드가 잡고 있는 락 때문에 높은 우선순위 스레드가 대기하는 **우선순위 역전** 해결
- **설계 포인트**:
    - 락 보유자에게 **우선순위 전달**(재귀 기부: 체인 따라가며 전파)
    - 락 해제 시 **원래 우선순위로 복구**(다중 기부 원자성 보장)

### **4) 고급 스케줄러 — MLFQS (Multi-Level Feedback Queue Scheduler)**

- **하는 일**: 우선순위를 **nice 값과 최근 CPU 사용량**으로 **자동 계산**하는 비자발적(기부 없는) 스케줄러
- **설계 포인트**:
    - **fixed-point** 연산으로 부동소수점 없이 계산
    - **주기적 우선순위 재산정**과 최근 CPU, 로드 애버리지 갱신
    - 타이머 tick과의 **정확한 타이밍 계약** 유지

### **5) 동기화 원시(Primitives) 정확성 재검증**

- **하는 일**: 세마포어/락/조건변수가 스케줄러와 함께 **일관되게 동작**해야 함
- **설계 포인트**:
    - 대기 큐 정렬 기준(우선순위) 통일
    - **signal/broadcast**의 깨우기 정책과 즉시 선점 여부 점검

## **디렉터리 개요 (간단)**

- pintos/threads/ : 스케줄러, 동기화 원시, 타이머 인터럽트, 스레드 제어 블록
- pintos/devices/ : 타이머/콘솔 등 기본 장치 드라이버
- pintos/tests/ : 채점 및 개별 테스트 프로그램(과제 배포본 기준)

## 테스트 결과 : ALL Passed ✅ (27/27)
<img width="700" alt="스크린샷 2025-10-16 오후 6 28 12" src="https://github.com/user-attachments/assets/ad0fad7f-b8af-4a5c-ab89-f0b6f32780cc" />


## **참고 자료**

- KAIST Pintos Project 1 공식 문서
    
    https://casys-kaist.github.io/pintos-kaist/project1/introduction.html

    
---

<br>

# **Pintos Project 2 — User Programs (KAIST)**

**Pintos**는 “커널만 있는 장난감”이 아니라 **사용자 프로그램을 실행하는 진짜 OS**로 확장됩니다. Project 2는 **사용자 프로세스의 로딩·실행·종료**, 그리고 **시스템 콜 인터페이스**를 구현하는 단계입니다. 사용자와 커널의 **경계(격리)**, **자원 소유권**과 **오류 처리**를 다루며, 이후 가상 메모리/파일시스템 확장의 토대를 만듭니다.

## **프로젝트 2 한눈에 보기**

- **무엇을 만드나?**
    
    ELF 실행 파일 **로더**, **인자 전달(스택 초기화)**, **프로세스 생성·대기(Exec/Wait)**, 그리고 파일 관련을 포함한 **시스템 콜 집합**을 구현합니다. 각 프로세스는 자체 **파일 디스크립터 테이블(FDT)** 을 가지며, 커널은 **불법 메모리 접근을 방어**해야 합니다.
    
- **왜 배우나? (교육적 의도)**
    - **사용자/커널 경계**: 포인터 검증, 커널 진입 시 **신뢰 경계 처리**를 배웁니다.
    - **프로세스 수명주기**: 로딩-실행-종료와 **부모/자식 동기화**를 구현합니다.
    - **자원 관리와 보안**: 파일 디스크립터, 경합, **DoS 방지**를 다룹니다.

## **구현 기능 요약 (쉽게 설명 + 설계 포인트)**

### **1) 시스템 콜 핸들러**

- **하는 일**: 유저 프로그램이 커널 기능을 요청(인터럽트/트랩)하면 **인자 파싱 → 검증 → 수행 → 반환**
- **대상 콜(전형적)**:
    
    halt, exit, exec, wait, create, remove, open, filesize, read, write, seek, tell, close
    
- **설계 포인트**:
    - **유저 포인터 철저 검증**(NULL/커널 영역/매핑 여부)
    - 커널 버퍼와 사용자 버퍼 간 **안전한 복사**
    - 파일시스템 전역 락의 **보유 범위 최소화**, 재진입/기아 주의

### **2) 프로세스 생성과 동기화 (exec, wait)**

- **하는 일**: 부모가 exec로 자식 실행을 요청 → 자식이 **ELF 로딩 성공/실패**를 부모에게 알려줄 때까지 **정확히 동기화**
- **설계 포인트**:
    - 로딩 결과를 부모에게 전달하기 위한 **세마포어/조건변수**
    - wait는 **한 번만** 성공해야 하며, 대기 중 **부모/자식 종료 순서**를 올바르게 처리

### **3) ELF 로더 & 스택 초기화(인자 전달)**

- **하는 일**: 실행 파일의 프로그램 헤더를 읽어 **코드/데이터 세그먼트**를 매핑하고, 스택에 **argv/argc** 형식으로 인자를 배치
- **설계 포인트**:
    - 페이지 정렬/권한(R/W/X) 검증과 로딩 범위 확인
    - 스택은 **워드 정렬**(alignment) 지키고, **argv/argc/NULL terminator/return address** 순서대로 배치

### **4) 파일 디스크립터 테이블(FDT)**

- **하는 일**: 프로세스별 열린 파일을 **정수 FD → 파일 객체**로 관리
- **설계 포인트**:
    - 0(stdin), 1(stdout) 예약 처리
    - open/close의 **자원 소유권** 분명히, 중복 FD/에러 시 정리 확실히
    - 다중 프로세스에서 **파일시스템 동기화** 및 **쓰기/읽기 상호작용** 보장

### **5) 메모리 접근 방어 & 예외 처리**

- **하는 일**: 시스템 콜 인자가 잘못된 주소를 가리키거나, 읽을 수 없는 영역을 건드리면 **프로세스를 안전하게 종료**
- **설계 포인트**:
    - 커널 진입 전후 **예외 경로**에서 리소스 누수 없이 정리
    - 유저 버퍼 I/O 중 페이지 폴트 대응(Proj3 이전에는 보수적으로 처리)

### **6) 거부 서비스(DoS) 및 경합 이슈 예방**

- **하는 일**: 악의적/버그성 유저 프로그램이 커널을 **오랫동안 붙잡지 못하게** 설계
- **설계 포인트**:
    - 긴 작업의 **락 보유 최소화**
    - 반복 호출 패턴에서 **공정성** 유지(선점, 락 정책)

## **디렉터리 개요 (간단)**

- pintos/userprog/ : 시스템 콜, 프로세스 로더, 인자 전달, 부모/자식 동기화
- pintos/threads/ : 스레드/락/세마포어 등 커널 공통 인프라
- pintos/filesys/ : 파일 시스템 인터페이스(Proj2에선 주로 API 사용·동기화)
- pintos/tests/ : 채점 및 개별 테스트 프로그램(과제 배포본 기준)

## 테스트 결과 : ALL Passed ✅ (95/95)
<img width="700" alt="스크린샷 2025-10-16 오후 6 29 25" src="https://github.com/user-attachments/assets/1356f26a-7bba-4cbe-9904-3714e2349259" />



## **참고 자료**

- KAIST Pintos Project 2 공식 문서
    
    https://casys-kaist.github.io/pintos-kaist/project2/introduction.html



---

<br>

# **Pintos Project 3 — Virtual Memory**

**Pintos**는 교육용 운영체제 커널입니다. 리눅스처럼 거대한 코드베이스를 한 번에 이해하기 어렵다는 문제를 해결하기 위해, **작고 읽기 쉬우며 실험 가능한** 커널 골격을 제공합니다. 학생은 여기에 **스레드, 프로세스, 파일 시스템, 가상 메모리** 같은 핵심 기능을 직접 붙여 넣으며, 단순한 라이브러리 코딩이 아닌 **시스템 수준의 설계·디버깅 경험**을 얻게 됩니다.

Project 3의 주제인 **가상 메모리(Virtual Memory)** 는 현대 OS가 프로세스들을 **서로 격리**하고, **메모리를 효율적으로 사용**하며, **큰 프로그램도 적은 물리 메모리에서 실행**되게 하는 핵심 기술입니다. 이 과제를 통해 “페이지 폴트가 왜 생기고, OS가 그 순간 무슨 일을 하는가?”를 실제 커널 코드로 체감하게 됩니다.


## **프로젝트: 3 (가상 메모리)**

- **무엇을 만드나?**
    
    페이지 단위로 메모리를 관리하는 **가상 메모리 서브시스템**을 확장합니다. 필요할 때만 페이지를 채우는 **지연 로딩(lazy/demand paging)**, 물리 메모리가 모자라면 디스크로 내보내는 **스왑(swap)**, 파일 내용을 메모리에 투명하게 매핑하는 **mmap/munmap** 등을 구현합니다.
    
- **왜 배우나?**
    - **격리와 안정성**: 잘못된 접근을 잡아내고 프로세스를 종료하는 **페이지 폴트 처리**를 익힙니다.
    - **효율성**: 실제로 접근한 데이터만 로딩하는 **지연 로딩**으로 입출력과 메모리 낭비를 줄입니다.
    - **자원 관리**: **프레임 테이블 + 교체 정책**으로 물리 메모리를 공정하게 배분합니다.
    - **영속성과 일관성**: 파일-백드 페이지의 **쓰기 반영(write-back)** 과 **동기화**를 다룹니다.
    - **경합/락 설계**: 여러 실행 흐름이 동일 자원을 안전하게 공유하도록 **동기화**를 설계합니다.


## **구현 기능 요약 (설계 포인트)**

### **1) 보조 페이지 테이블(Supplemental Page Table; SPT)**

- **하는 일**: “이 가상 주소의 페이지는 어떤 타입이고, 어디서 어떻게 채워야 하는가?”를 기록하는 **프로세스 전용 메타데이터** 사전입니다.
- **왜 필요?**: 하드웨어 페이지 테이블은 “매핑됨/안 됨”만 알기 쉬운데, **어떻게 로드할지**(파일에서? 스왑에서? 0으로?)는 OS가 기억해야 함.
- **설계 포인트**
    - 해시/트리 등으로 **빠른 조회**(평균 O(1))
    - 키: 페이지 **기준 주소(페이지 정렬된 VA)**
    - 값: **페이지 타입(익명/파일-백드)**, 소스(파일+오프셋/스왑 슬롯), 권한 등

### **2) 지연 로딩(Lazy Loading) & 수요 페이징(Demand Paging)**

- **하는 일**: 실행 시 파일 전체를 읽지 않고, **접근하는 순간**(페이지 폴트 시) 필요한 페이지만 로드합니다.
- **설계 포인트**
    - SPT에 “어떻게 채울지”만 미리 적어 놓고, **첫 접근 때 vm_claim_page()** 로 실제 할당/적재
    - 파일-백드: 파일에서 읽어 채움, 익명: 0으로 초기화

### **3) 프레임 테이블(Frame Table) & 교체 정책(Eviction)**

- **하는 일**: “RAM에 어떤 페이지가 어느 프레임에 들어있는지”를 추적하고, RAM이 가득 차면 **누구를 내보낼지** 결정합니다.
- **교체 정책**: 예) **Clock/Second-chance** — 최근에 안 쓰인 페이지부터 희생
- **설계 포인트**
    - 프레임 <-> SPT 엔트리 간 **양방향 연결**(역참조)
    - I/O 중인 프레임은 **핀(pin)** 으로 잠깐 희생 금지
    - 락 순서/보유 기간을 짧게 유지해 **교착 방지**

### **4) 스왑(Swap) — 익명 페이지 내보내기/가져오기**

- **하는 일**: 익명 페이지(스택/힙 등)를 디스크 **스왑 영역**에 저장했다가 필요하면 다시 불러옵니다.
- **설계 포인트**
    - “한 페이지 = 고정된 섹터 수” 단위로 **슬롯 관리**(할당/해제 비트맵 등)
    - 스왑아웃: 프레임 → 디스크, SPT에 “이 페이지는 스왑 슬롯 #n”으로 갱신
    - 스왑인: 다시 RAM으로 가져오고 슬롯 해제

### **5) 파일-백드 페이지 & 메모리 매핑(mmap/munmap)**

- **하는 일**: 파일의 일부를 메모리에 매핑하여 **파일 I/O를 메모리 접근처럼** 사용할 수 있게 합니다.
- **지연 로딩**과 결합되어, 접근 시 해당 부분만 파일에서 읽어 옵니다.
- **munmap**: 더티 페이지는 파일에 **write-back**, 클린 페이지는 해제
- **주소 선택 힌트**: addr == NULL 인 경우, **연속된 빈 가상 주소 구간**을 찾아 시작 주소를 정합니다(페이지 정렬/유저 영역/겹침 금지 검사).

### **6) 스택 자동 성장(Stack Growth)**

- **하는 일**: 프로그램이 스택을 조금씩 더 쓰면, OS가 **허용 범위 내에서** 새 페이지를 만들어 스택을 확장합니다.
- **설계 포인트**
    - “폴트 주소가 현재 스택 포인터 근처인가?” 등 **합법 조건** 판정
    - 성공 시 익명 페이지를 **claim** 해서 0-초기화

### **7) 페이지 폴트 처리기(Page Fault Handler)**

- **하는 일**: 접근 예외가 나면 원인을 분석(존재X/권한X/커널 접근 등)하고, **정상적인 경우에는 필요한 페이지를 즉시 준비**합니다.
- **일반 흐름**
    1. SPT 조회 → 있으면 타입별 로드(파일/스왑/0-fill)
    2. 없으면 **스택 성장 조건**인지 확인 후 확장
    3. 진짜 오류(권한 위반 등)면 프로세스 종료

### **8) 동기화 & 오류 처리**

- **하는 일**: 파일 시스템 락, 프레임 락, SPT 락 등 **여러 락의 순서**를 안정적으로 맞춰 교착을 방지합니다.
- **설계 포인트**
    - **락 획득/해제의 일관성**
    - 인터럽트 컨텍스트에서 금지해야 할 작업 회피
    - 실패 시 **자원 정리**(파일 핸들/슬롯/프레임) 확실히


## **디렉터리 개요**

- pintos/vm/ : VM 핵심 코드(페이지 타입, 프레임/스왑/클레임 로직 등)
- pintos/userprog/ : 시스템콜, 프로세스 로딩/페이지 폴트 진입부
- pintos/threads/ : 스케줄러·락·페이지 할당자 등 커널 공통
- pintos/tests/ : 채점 및 개별 테스트 프로그램(과제 배포본 기준)


## 테스트 결과 : ALL Passed ✅ (140/140)

<img width="700" alt="스크린샷 2025-10-16 오후 6 31 57" src="https://github.com/user-attachments/assets/5fcdcf93-f8ae-49b9-8b19-1475ecc5fa2a" />


## **참고 자료**

- KAIST Pintos Project 3 공식 문서
    
    https://casys-kaist.github.io/pintos-kaist/project3/introduction.html
- Project 3 Team Repository
  
    https://github.com/hyeondxo/pintos3-virtual-memory
